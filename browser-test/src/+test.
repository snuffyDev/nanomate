export interface TweenOptions {
	duration: number;
	delay?: number;
	easing?: string;
	composite?: CompositeOperation,
	iterations?: number | "infinite";
	direction?: "normal" | "reverse" | "alternate" | "alternate-reverse";
	fill?: "none" | "forwards" | "backwards" | "both" | "auto";
}
interface Point {
	x: number;
	y: number;
}

function convertSvgPathToTranslate(svgPath: string): Point[] {
	const pathElement = document.createElementNS(
		"http://www.w3.org/2000/svg",
		"path",
	);

	pathElement.setAttribute("d", svgPath);
	const totalLength = pathElement.getTotalLength();
		const first = pathElement.getPointAtLength(0);
	const step = 5; // Increase or decrease this value to control the precision
		console.log(totalLength)
	const points: DOMPoint[] = Array(Math.floor((totalLength -1) / step));
	for (let length = 0, current = 0; length <= totalLength; length += step) {
		const point = pathElement.getPointAtLength(length);
		points[current++] = point;
	}

	return points;
}

type BaseTransform = "scale" | "translate" | "rotate" | "skew";
type Transforms = `${BaseTransform}${"X" | "Y" | "Z" | "3d"}`;

const TRANSFORM_KEYS = [
	"scaleX",
	"scaleY",
	"scaleZ",
	"scale3d",
	"translateX",
	"translateY",
	"translateZ",
	"translate3d",
	"rotateX",
	"rotateY",
	"rotateZ",
	"rotate3d",
	"skewX",
	"skewY",
	"skewZ",
	"skew3d",
] as const;
interface Keyframe {
	transform: string;
	[property: string]: string;
}

function adjustTransformsForScale(
	keyframes: Keyframe,
	element: HTMLElement,
): Keyframe[] {
	const adjustedKeyframes: Keyframe[] = [];

	// for (const keyframe of keyframes) {
	const transform = keyframes?.transform;
	const matchTranslate = transform?.match(/translate\([^)]+\)/);
	const matchScaleProperty = keyframes?.scale;
	const matchScaleFunction = transform?.match(/scale[XYZ]?3?d?\([^)]+\)/);

	let currentScale = 1;

	if (matchScaleProperty) {
		currentScale = parseFloat(matchScaleProperty);
	} else if (matchScaleFunction) {
		const scaleValue = matchScaleFunction[0].match(/(-?\d*\.?\d+)/);
		if (scaleValue) {
			currentScale = parseFloat(scaleValue[0]);
		}
	} else {
		const computedTransform = getComputedStyle(element).transform;
		const matchComputedScale = computedTransform.match(/scale\([^)]+\)/);
		if (matchComputedScale) {
			const scaleValue = matchComputedScale[0].match(/(-?\d*\.?\d+)/);
			if (scaleValue) {
				currentScale = parseFloat(scaleValue[0]);
			}
		}
		if (matchTranslate) {
			const translate = matchTranslate[0];
			const scaleFactor = currentScale;
			const adjustedTranslate = translate.replace(
				/(-?\d*\.?\d+)([a-z%]+)/g,
				(_, value, unit) => `${parseFloat(value) * scaleFactor}${unit}`,
			);
			const adjustedTransform = transform.replace(translate, adjustedTranslate);

			keyframes = { ...keyframes, transform: adjustedTransform };
			return [keyframes];
		} else {
			return [keyframes];
		}
		return [keyframes];
	}
	return [keyframes];
}

export class Tween {
	protected target: HTMLElement;
	protected srcKeyframes: Keyframe[];
	protected options: TweenOptions;
	protected animation: Animation | null;
	protected keyframes: Keyframe[];
	protected _keyframes: KeyframeEffect;
	protected tick: (frames: Keyframe[]) => FrameRequestCallback;
	protected transforms: CSSTransform[] = [];
	public get duration() {
		return this.options.duration;
	}
	private startTime!: number;
	private pauseTime!: number;
	private endTime!: number;

	constructor(
		target: HTMLElement,
		keyframes: Keyframe[],
		options: TweenOptions,
	) {
		this.target = target;
		this.srcKeyframes = this.keyframes = keyframes;

		this.options = options;
		this.animation = null;
		this.tick = (frames: Keyframe[]) => {
			const run = (now: number) => {
				if (!this.startTime) this.startTime = now;
				let t = (now - this.startTime) * 1;

				t /= 1000;

				const progress = t * this.srcKeyframes.length;

				const current = Math.floor(progress);

				if (current >= frames.length) return;

				requestAnimationFrame(run);
			};
			return run;
		};
	}

	public start(): void {
		this._keyframes = new KeyframeEffect(
			this.target,
			this.keyframes as never,
			this.options as never,
		);
		// this.transforms = adjustTransformsForScale(this.keyframes, this.target)

		this.animation = new Animation(this._keyframes, document.timeline);

		this.animation.play();

		requestAnimationFrame(this.tick(this._keyframes.getKeyframes()));
		console.warn(this._keyframes);
	}

	public pause(): void {
		if (this.animation) {
			this.animation.pause();
		}
	}

	public resume(): void {
		if (this.animation) {
			this.animation.play();
		}
	}

	public reverse(): void {
		if (this.animation) {
			this.animation.reverse();
		}
	}

	public cancel(): void {
		if (this.animation) {
			this.animation.cancel();
			this.animation = null;
		}
	}

	public onComplete(callback: () => void): void {
		if (this.animation) {
			this.animation.onfinish = callback;
		}
	}
}

export interface PathTweenOptions extends TweenOptions {
	path: string | SVGPathElement;
}

interface Point {
	x: number;
	y: number;
}

function scalePoints(
	points: Point[],
	targetWidth: number,
	targetHeight: number,
): Point[] {
	// Find the maximum x and y values of the points
	let maxX = Number.MIN_VALUE;
	let maxY = Number.MIN_VALUE;
	for (const point of points) {
		if (point.x > maxX) {
			maxX = point.x;
		}
		if (point.y > maxY) {
			maxY = point.y;
		}
	}

	// Calculate the scaling factors
	const scaleX = targetWidth / maxX;
	const scaleY = targetHeight / maxY;

	// Scale the points
	const scaledPoints: Point[] = [];
	for (const point of points) {
		const scaledX = point.x * scaleX;
		const scaledY = point.y * scaleY;
		scaledPoints.push({ x: scaledX, y: scaledY });
	}

	return scaledPoints;
}

export class PathTween extends Tween {
	private path: SVGPathElement;

	constructor(
		target: HTMLElement,
		keyframes: Keyframe[],
		options: PathTweenOptions,
	) {
		super(target, keyframes, options);
		this.path =
			typeof options.path === "string"
				? document.querySelector(options.path)!
				: options.path;

		if (typeof VisualViewport !== "undefined") {
			visualViewport?.addEventListener("resize", () => this.onViewportResize());
		}
	}

	private onViewportResize() {
		const currentTime = this.animation?.currentTime;

		this.cancel(); // Cancel the current animation
		this.animatePath(); // Reinitialize the new keyframes
		this.animation!.currentTime = currentTime!; // Pick-up where we last left off!
	}
	public animatePath(reverse = false): void {
		const pathLength = this.path.getTotalLength();

		if (!this.path || pathLength === 0) {
			console.error(
				"Invalid SVG path element, path length, or screen width is zero.",
			);
			return;
		}

		const node = this.path;
		const origin = node.getPointAtLength(0);
		const end = node.getPointAtLength(pathLength);
		const boundingClient = this.path.getBoundingClientRect();

		const segments = convertSvgPathToTranslate(this.path.getAttribute("d")!);
		console.log(segments.length)

		const frames = scalePoints(
			segments.length > 1 ? segments: [origin, end],
			boundingClient.width,
			boundingClient.height,
		);

		const lerpFrames = [...this.srcKeyframes];

		const numKeyframes = frames.length;
		const numLerpFrames = lerpFrames.length;
		if (numLerpFrames === 1) {
			for (let idx=0; idx < frames.length-1;) {
				if (!(idx % frames.length)) {
				for (const key in )

				}
			}
		}

		console.log(numLerpFrames);
		console.log(boundingClient)
		const keyframes: Keyframe[] = frames.map((point, index) => {
			const keyframeIndex = Math.floor((index / numKeyframes) * numLerpFrames);
			const frame = lerpFrames[keyframeIndex];
			const entries = Object.entries(frame);

			let css = {} as Record<string, string>
			if (Object.values(frame).every(Array.isArray)) {
				for (const [key, value] of entries) {
					css[key] =
				}
			}

			const n = ((index ?? 1 + 1) * numLerpFrames) / numKeyframes;
			const t = ((index - 1) % numLerpFrames);
			const { scale = undefined, ...rest } = frame;
			console.log((t || t + 1))
			return {
				...(!((t)) && rest),
				transform: `translate(${
					point.x + this.target.clientWidth
				}px, ${  point.y + this.target.clientHeight }px) ${
					scale ? `scale(${scale})` : ""
				}`,
			};
		});
		console.log(keyframes)
		this.keyframes = reverse ? keyframes.reverse() : keyframes;
		this.start();
	}
}
